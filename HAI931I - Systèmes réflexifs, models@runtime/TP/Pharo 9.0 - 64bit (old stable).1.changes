----QUIT----2022-09-06T11:28:24.088812+02:00 Pharo9.0-SNAPSHOT-64bit-e1bb0fb.image priorSource: 0!----QUIT----2022-09-06T11:29:02.171389+02:00 Pharo9.0-SNAPSHOT-64bit-e1bb0fb.image priorSource: 0!----SNAPSHOT----2022-09-12T15:36:14.915948+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 100!Object subclass: #Stack	instanceVariableNames: '' 	classVariableNames: ''	package: 'AAMartinClasses'!Object subclass: #MartinStack	instanceVariableNames: '' 	classVariableNames: ''	package: 'AAMartin'!Object subclass: #MartinStack	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	package: 'AAMartin'!!MartinStack methodsFor: 'as yet unclassified' stamp: 'MArtin 9/12/2022 16:11'!initialize: taille	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"					index := 0.	capacite := taille.	contenu  := Array new: capacite.! !----SNAPSHOT----2022-09-12T16:30:08.308841+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 200!----QUIT----2022-09-12T16:30:14.600661+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 929!Smalltalk globals removeClassNamed: #AnObsoleteMartinStack!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	poolDictionaries: ''	category: 'ExosPharo-PileDistrib'!!Pile methodsFor: 'as yet unclassified' stamp: 'MArtin 9/19/2022 15:08'!printOn: aStream	"Cette méthode est appelée par la méthode printString qui fabrique une représentation du    receveur sous forme de chaîne.	 PrintString est elle-même appelée par les outils de l'environnement, par exemple par la    méthode printIt du Playground."		aStream nextPutAll: 'une Pile, de taille: '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant: '.	index printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu do: [ :each | each printOn: aStream. aStream space ].	aStream nextPut: $).! !!Pile methodsFor: 'as yet unclassified' stamp: 'MArtin 9/19/2022 15:09'!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'as yet unclassified' stamp: 'MArtin 9/19/2022 15:09'!isEmpty	^index = 0! !!Pile methodsFor: 'as yet unclassified' stamp: 'MArtin 9/19/2022 15:09'!isFull	^index = capacite! !!Pile methodsFor: 'as yet unclassified' stamp: 'MArtin 9/19/2022 15:10'!pop	"dépile et rend le sommet de pile si la pile n'est pas vide"	| retour |	self isEmpty		ifFalse: [			retour := contenu at: index.			index := index - 1.			^retour]		ifTrue: [ self error: 'Pile vide, Impossible de dépiler' ]! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:10'!size	"donne le nombre d'éléments empilés"	^index		"^contenu count: [ :each | each isNotNil ]"! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:10'!top	"rend le sommet de pile si la pile n'est pas vide, sans dépiler"	self isEmpty		ifFalse: [ ^contenu at: index]		ifTrue: [ self error: 'Rien au sommet d''une pile vide' ]! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:10'!grow	| nb oldc |	nb := self size.	oldc := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	0 to: nb do: [ :i |  self push: (oldc at: i)]! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:10'!capacity	^capacite! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:10'!initialize: taille	"initialise les attribus d'une pile nouvellement créée"	"la pile est vide quand index = 0"	index := 0.	"la pile est pleine quand index = capacite"	capacite := taille.	"le contenu est représenté par un tableau"	contenu := Array new: capacite.		self assert: (self isEmpty).! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:10'!hasBufferEqualTo: contenu1	^contenu = contenu1! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:11'!= unePile	^unePile hasBufferEqualTo: contenu! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:11'!initialize	tailleDefaut := 5! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:11'!new: taille	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^super new  initialize: taille! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:12'!new	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^self new: tailleDefaut! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:12'!example	"self example" 	"Un exemple de la façon dont on peut utiliser une pile dans un programme"	| p |	p := Pile new.	p push: 33.	p push: 'une chaine'.	p push: 2 @ 3.	p push: 5 factorial.	p push: p isFull.	p pop.	p push: p size.	^p! !Pile removeSelector: #example!!Pile class methodsFor: 'as yet unclassified' stamp: 'MArtin 9/19/2022 15:15'!example	"self example" 	"Un exemple de la façon dont on peut utiliser une pile dans un programme"	| p |	p := Pile new.	p push: 33.	p push: 'une chaine'.	p push: 2 @ 3.	p push: 5 factorial.	p push: p isFull.	p pop.	p push: p size.	^p! !Object subclass: #MyClass	instanceVariableNames: '' 	classVariableNames: ''	package: 'AAMartin'!Smalltalk globals removeClassNamed: #AnObsoleteMyClass!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	package: 'AAMartin'!'From Pharo6.0 of 13 May 2016 [Latest update: #60535] on 6 April 2018 at 8:18:17.195167 am'!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	poolDictionaries: ''	category: 'ExosPharo-PileDistrib'!!Pile commentStamp: 'cd 3/8/2017 10:34' prior: 0!Implantation d'une pile en utilisant une collection ordonnée.Internal Representation and Key Implementation Points.    Instance Variables	contenu:		<Collection>	index:		<Integer>	taille:		<Integer>    Implementation Points!!Pile methodsFor: 'printing' stamp: 'cd 3/15/2017 12:27' prior: 33555869!printOn: aStream	"Cette méthode est appelée par la méthode printString qui fabrique une représentation du    receveur sous forme de chaîne.	 PrintString est elle-même appelée par les outils de l'environnement, par exemple par la    méthode printIt du Playground."		aStream nextPutAll: 'une Pile, de taille: '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant: '.	index printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu do: [ :each | each printOn: aStream. aStream space ].	aStream nextPut: $).! !!Pile methodsFor: 'métier' stamp: 'cd 3/8/2017 12:25' prior: 33556478!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:53' prior: 33556796!isEmpty	^index = 0! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:53' prior: 33556892!isFull	^index = capacite! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:54' prior: 33556994!pop	"dépile et rend le sommet de pile si la pile n'est pas vide"	| retour |	self isEmpty		ifFalse: [			retour := contenu at: index.			index := index - 1.			^retour]		ifTrue: [ self error: 'Pile vide, Impossible de dépiler' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:06' prior: 33557294!size	"donne le nombre d'éléments empilés"	^index		"^contenu count: [ :each | each isNotNil ]"	! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:55' prior: 33557460!top	"rend le sommet de pile si la pile n'est pas vide, sans dépiler"	self isEmpty		ifFalse: [ ^contenu at: index]		ifTrue: [ self error: 'Rien au sommet d''une pile vide' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:22' prior: 33557704!grow	| nb oldc |	nb := self size.	oldc := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	0 to: nb do: [ :i |  self push: (oldc at: i)]	! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:01' prior: 33557930!capacity	^capacite	! !!Pile methodsFor: 'initialization' stamp: 'cd 3/28/2018 12:53' prior: 33558015!initialize: taille	"initialise les attribus d'une pile nouvellement créée"	"la pile est vide quand index = 0"	index := 0.	"la pile est pleine quand index = capacite"	capacite := taille.	"le contenu est représenté par un tableau"	contenu := Array new: capacite.		self assert: (self isEmpty).	! !!Pile methodsFor: 'private' stamp: 'cd 4/5/2018 12:15' prior: 33558384!hasBufferEqualTo: contenu1	^contenu = contenu1! !!Pile methodsFor: 'comparing' stamp: 'cd 4/5/2018 12:15' prior: 33558497!= unePile	^unePile hasBufferEqualTo: contenu! !!Pile methodsFor: 'enumerating' stamp: 'cd 4/15/2016 10:37'!do: aBlock	"un itérateur pour la classe Pile"	buffer do: aBlock.					! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pile class	instanceVariableNames: ''!!Pile class methodsFor: 'instance creation' stamp: 'cd 3/28/2018 12:56'!initialize	tailleDefaut := 5.! !!Pile class methodsFor: 'instance creation' stamp: 'cd 4/5/2018 12:47'!new: taille	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^super new  initialize: taille	! !!Pile class methodsFor: 'instance creation' stamp: 'cd 4/5/2018 12:47'!new	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^self new: tailleDefaut	! !!Pile class methodsFor: 'examples' stamp: 'cd 3/28/2018 14:39' prior: 33559578!example	"self example" 	"Un exemple de la façon dont on peut utiliser une pile dans un programme"	| p |	p := Pile new.	p push: 33.	p push: 'une chaine'.	p push: 2 @ 3.	p push: 5 factorial.	p push: p isFull.	p pop.	p push: p size.	^p! !Pile initialize!----End fileIn----!'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 25 September 2020 at 11:56:36.70264 am'!TestCase subclass: #TestPile	instanceVariableNames: 'standard pleine vide'	classVariableNames: ''	package: 'ExosPharo-7-PileDistrib'!!TestPile methodsFor: 'initialization' stamp: 'cd 3/14/2019 15:34'!setUp	"une pile vide"	vide := Pile new initialize: 3.		"une pile dans un état quelconque, ni vide ni pleine"	standard := Pile new initialize: 4.	standard push: 1.		"une pile pleine"	pleine := Pile new initialize: 2.	pleine push: 1.	pleine push: 2.! !!TestPile methodsFor: 'tests' stamp: 'cd 3/14/2019 16:03'!testEqual	| copy |	copy := standard shallowCopy.	self assert: standard equals: copy.! !!TestPile methodsFor: 'tests' stamp: 'cd 3/22/2019 18:25'!testPush	self should: [ pleine push: #anything ] raise: Error.	self testPush: vide.	self testPush: standard.! !!TestPile methodsFor: 'tests' stamp: 'cd 3/8/2017 11:43'!testVide	self assert: vide isEmpty	! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:37'!testPop: unePile	"attention à ce que standard reste standard, ni vide ni pleine, pour les autres méthodes de test"	| p1 p2 |	p1 := unePile top.	p2 := unePile pop.	self deny: unePile isFull.	self assert: p2 equals: p1.	unePile push: p1.	self assert: unePile top equals: p2.! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:38'!testPop	self should: [ vide pop ] raise: Error.	self testPop: standard.	self testPop: pleine.! !!TestPile methodsFor: 'tests' stamp: 'cd 4/5/2018 13:08'!testEquals	self assert: standard = standard! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:32'!testFull	self assert: pleine isFull.	self deny: standard isFull.	self deny: vide isFull.! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:36'!testPush: unePile	| sauve |	sauve := unePile.	unePile push: 33.	self deny: unePile isEmpty.	self assert: unePile top equals: 33.	self assert: unePile pop equals: 33.	"on laisse la pile dans l'état ou elle était en entrant"	self assert: unePile equals: sauve.		! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:44'!testEmpty	"vide, standard et pleine référencent des piles  créées dans la méthode setUp"	self assert: vide isEmpty.	self deny: standard isEmpty.	self deny: pleine isEmpty.! !----End fileIn----!Pile removeSelector: #do:!TestCase subclass: #TestPile	instanceVariableNames: 'standard pleine vide'	classVariableNames: ''	package: 'AAMartin'!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	package: 'AAMartin'!!Pile methodsFor: 'métier' stamp: 'MArtin 9/19/2022 15:35' prior: 33561344!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self halt.	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'métier' stamp: 'MArtin 9/19/2022 15:35' prior: 33567552!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self halt	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'métier' stamp: 'MArtin 9/19/2022 15:35' prior: 33567886!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self halt.			self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'métier' stamp: 'MArtin 9/19/2022 15:39' prior: 33568219!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	Halt now.		self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'métier' stamp: 'MArtin 9/19/2022 15:39' prior: 33568555!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	"Halt now.	"	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile class methodsFor: 'as yet unclassified' stamp: 'MArtin 9/19/2022 16:09' prior: 33563818!	initialize 		tailleDefaut := 5! !!Pile class methodsFor: 'initialization' stamp: 'MArtin 9/19/2022 16:09' prior: 33569243!initialize 		tailleDefaut := 5.! !!Pile class methodsFor: 'as yet unclassified' stamp: 'MArtin 9/19/2022 16:10' prior: 33564201!new	self initialize.! !----QUIT----2022-09-19T16:31:01.54494+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 1034!!Pile class methodsFor: 'instance creation' stamp: 'MArtin 9/26/2022 15:42' prior: 33569500!new	^super new  initialize	! !!Pile class methodsFor: 'instance creation' stamp: 'MArtin 9/26/2022 15:43' prior: 33569719!new	^super	! !!Pile class methodsFor: 'instance creation' stamp: 'MArtin 9/26/2022 15:43' prior: 33569846!new	^super new	! !Pile class removeSelector: #new!Pile class removeSelector: #new:!Pile class removeSelector: #initialize!Pile removeSelector: #initialize!Smalltalk globals removeClassNamed: #AnObsoletePile!Smalltalk globals removeClassNamed: #AnObsoleteTestPile!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	package: 'AAMartin'!!Pile commentStamp: 'cd 3/8/2017 10:34' prior: 0!Implantation d'une pile en utilisant une collection ordonnée.Internal Representation and Key Implementation Points.    Instance Variables	contenu:		<Collection>	index:		<Integer>	taille:		<Integer>    Implementation Points!!Pile methodsFor: 'initialization' stamp: 'cd 3/28/2018 12:53'!initialize: taille	"initialise les attribus d'une pile nouvellement créée"	"la pile est vide quand index = 0"	index := 0.	"la pile est pleine quand index = capacite"	capacite := taille.	"le contenu est représenté par un tableau"	contenu := Array new: capacite.		self assert: (self isEmpty).	! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:55'!top	"rend le sommet de pile si la pile n'est pas vide, sans dépiler"	self isEmpty		ifFalse: [ ^contenu at: index]		ifTrue: [ self error: 'Rien au sommet d''une pile vide' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:54'!pop	"dépile et rend le sommet de pile si la pile n'est pas vide"	| retour |	self isEmpty		ifFalse: [			retour := contenu at: index.			index := index - 1.			^retour]		ifTrue: [ self error: 'Pile vide, Impossible de dépiler' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:01'!capacity	^capacite	! !!Pile methodsFor: 'métier' stamp: 'MArtin 9/19/2022 15:39'!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	"Halt now.	"	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:53'!isFull	^index = capacite! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:06'!size	"donne le nombre d'éléments empilés"	^index		"^contenu count: [ :each | each isNotNil ]"	! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:53'!isEmpty	^index = 0! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:22'!grow	| nb oldc |	nb := self size.	oldc := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	0 to: nb do: [ :i |  self push: (oldc at: i)]	! !!Pile methodsFor: 'printing' stamp: 'cd 3/15/2017 12:27'!printOn: aStream	"Cette méthode est appelée par la méthode printString qui fabrique une représentation du    receveur sous forme de chaîne.	 PrintString est elle-même appelée par les outils de l'environnement, par exemple par la    méthode printIt du Playground."		aStream nextPutAll: 'une Pile, de taille: '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant: '.	index printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu do: [ :each | each printOn: aStream. aStream space ].	aStream nextPut: $).! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:12'!new	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^self new: tailleDefaut! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:11'!new: taille	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^super new  initialize: taille! !!Pile methodsFor: 'removing' stamp: 'MArtin 9/19/2022 15:11'!initialize	tailleDefaut := 5! !!Pile methodsFor: 'private' stamp: 'cd 4/5/2018 12:15'!hasBufferEqualTo: contenu1	^contenu = contenu1! !!Pile methodsFor: 'comparing' stamp: 'cd 4/5/2018 12:15'!= unePile	^unePile hasBufferEqualTo: contenu! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pile class	instanceVariableNames: ''!!Pile class methodsFor: 'instance creation' stamp: 'MArtin 9/19/2022 16:10'!new	self initialize.! !!Pile class methodsFor: 'instance creation' stamp: 'cd 4/5/2018 12:47'!new: taille	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^super new  initialize: taille	! !!Pile class methodsFor: 'initialization' stamp: 'MArtin 9/19/2022 16:09'!initialize 		tailleDefaut := 5.! !!Pile class methodsFor: 'examples' stamp: 'cd 3/28/2018 14:39'!example	"self example" 	"Un exemple de la façon dont on peut utiliser une pile dans un programme"	| p |	p := Pile new.	p push: 33.	p push: 'une chaine'.	p push: 2 @ 3.	p push: 5 factorial.	p push: p isFull.	p pop.	p push: p size.	^p! !TestCase subclass: #TestPile	instanceVariableNames: 'standard pleine vide'	classVariableNames: ''	package: 'AAMartin'!!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:36'!testPush: unePile	| sauve |	sauve := unePile.	unePile push: 33.	self deny: unePile isEmpty.	self assert: unePile top equals: 33.	self assert: unePile pop equals: 33.	"on laisse la pile dans l'état ou elle était en entrant"	self assert: unePile equals: sauve.		! !!TestPile methodsFor: 'tests' stamp: 'cd 4/5/2018 13:08'!testEquals	self assert: standard = standard! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:32'!testFull	self assert: pleine isFull.	self deny: standard isFull.	self deny: vide isFull.! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:44'!testEmpty	"vide, standard et pleine référencent des piles  créées dans la méthode setUp"	self assert: vide isEmpty.	self deny: standard isEmpty.	self deny: pleine isEmpty.! !!TestPile methodsFor: 'tests' stamp: 'cd 3/22/2019 18:25'!testPush	self should: [ pleine push: #anything ] raise: Error.	self testPush: vide.	self testPush: standard.! !!TestPile methodsFor: 'tests' stamp: 'cd 3/14/2019 16:03'!testEqual	| copy |	copy := standard shallowCopy.	self assert: standard equals: copy.! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:38'!testPop	self should: [ vide pop ] raise: Error.	self testPop: standard.	self testPop: pleine.! !!TestPile methodsFor: 'tests' stamp: 'cd 3/8/2017 11:43'!testVide	self assert: vide isEmpty	! !!TestPile methodsFor: 'tests' stamp: 'cd 9/25/2020 11:37'!testPop: unePile	"attention à ce que standard reste standard, ni vide ni pleine, pour les autres méthodes de test"	| p1 p2 |	p1 := unePile top.	p2 := unePile pop.	self deny: unePile isFull.	self assert: p2 equals: p1.	unePile push: p1.	self assert: unePile top equals: p2.! !!TestPile methodsFor: 'initialization' stamp: 'cd 3/14/2019 15:34'!setUp	"une pile vide"	vide := Pile new initialize: 3.		"une pile dans un état quelconque, ni vide ni pleine"	standard := Pile new initialize: 4.	standard push: 1.		"une pile pleine"	pleine := Pile new initialize: 2.	pleine push: 1.	pleine push: 2.! !Pile initialize!----End fileIn----!!Pile class methodsFor: 'instance creation' stamp: 'MArtin 9/26/2022 15:57' prior: 33574109!new	^super new initialize: tailleDefaut.! !!Pile class methodsFor: 'instance creation' stamp: 'MArtin 9/26/2022 16:14' prior: 33574206!new: taille 	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^super new  initialize: taille	! !!Pile class methodsFor: 'instance creation' stamp: 'MArtin 9/26/2022 16:15' prior: 33577185!new	^super new: tailleDefaut.! !!Pile class methodsFor: 'instance creation' stamp: 'MArtin 9/26/2022 16:16' prior: 33577622!new	^super new initialize: tailleDefaut.! !----SNAPSHOT----2022-09-26T16:26:54.958653+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 15092!----QUIT----2022-09-26T16:26:57.622369+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 23361!Object subclass: #Counter		instanceVariableNames: '' 	classVariableNames: ''	package: 'AAMartin'!!Counter class methodsFor: 'as yet unclassified' stamp: 'MArtin 10/3/2022 15:29'!create	| x |	x := 0.	^ [ x:= 	x+1 ]! !!Boolean methodsFor: 'as yet unclassified' stamp: 'MArtin 10/3/2022 15:48'!ifNotTrue: alternativeBlock 	^ self ifFalse: alternativeBlock.! !!Boolean methodsFor: 'as yet unclassified' stamp: 'MArtin 10/3/2022 15:48'!ifNotFalse: alternativeBlock 	^ self ifTrue: alternativeBlock.! !!BlockClosure methodsFor: 'as yet unclassified' stamp: 'MArtin 10/3/2022 15:57'!repeatUntil: condition	self value.		condition ifFalse: [ ^ self repeatUntil: condition ] 				 ifTrue: [  ]! !!BlockClosure methodsFor: 'as yet unclassified' stamp: 'MArtin 10/3/2022 15:58' prior: 33578597!repeatUntil: condition	self value.		condition ifFalse: [ ^ self repeatUntil: condition ] 				 ! !!BlockClosure methodsFor: 'as yet unclassified' stamp: 'MArtin 10/3/2022 15:58' prior: 33578808!repeatUntil: condition	self value.		condition ifFalse: [ ^ self repeatUntil: condition ] 				 ifTrue: [ nil ]! !----SNAPSHOT----2022-10-03T16:00:28.96671+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 23468!Object subclass: #Counter	instanceVariableNames: '' 	classVariableNames: ''	package: 'AAMartin'!!Counter class methodsFor: 'as yet unclassified' stamp: 'MArtin 10/3/2022 16:01'!create	| x |	x := 0.	^ [ x := x + 1 ]! !----SNAPSHOT----2022-10-03T16:01:13.312501+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 24691!----SNAPSHOT----2022-10-03T16:04:42.997917+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 25024!!BlockClosure methodsFor: 'as yet unclassified' stamp: 'MArtin 10/3/2022 16:08' prior: 33579007!repeatUntil: condition	self value.		condition value ifFalse: [ ^ self repeatUntil: condition. ] 				 ifTrue: [ ^ nil ]! !----SNAPSHOT----2022-10-03T16:08:48.317334+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 25131!----SNAPSHOT----2022-10-03T16:09:42.068005+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 25461!----SNAPSHOT----2022-10-03T16:32:00.926697+02:00 Pharo 9.0 - 64bit (old stable).image priorSource: 25568!----SNAPSHOT----2022-10-03T16:32:19.508816+02:00 Pharo 9.0 - 64bit (old stable).1.image priorSource: 25675!----QUIT----2022-10-03T16:32:23.932386+02:00 Pharo 9.0 - 64bit (old stable).1.image priorSource: 25782!